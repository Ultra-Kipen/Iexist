{"version":3,"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","processBackgroundImage","_slicedToArray2","processColor","DIRECTION_KEYWORD_REGEX","ANGLE_UNIT_REGEX","DEFAULT_DIRECTION","type","backgroundImage","result","parseCSSLinearGradient","replace","Array","isArray","bgImage","processedColorStops","index","colorStops","length","colorStop","processedColor","color","positions","position","endsWith","push","parseFloat","direction","bgDirection","toLowerCase","test","parsedAngle","getAngleInDegrees","parsedDirection","getDirectionForKeyword","fixedColorStops","getFixedColorStops","concat","cssString","gradients","match","linearGradientRegex","exec","gradientContent","parts","split","trimmedDirection","trim","colorStopRegex","shift","lastIndex","fullColorStopsStr","join","colorStopMatch","_colorStopMatch","_colorStopMatch2","position1","position2","normalized","angle","_match","unit","numericValue","Math","PI","_colorStops$0$positio","hasNullPositions","maxPositionSoFar","i","newPosition","max","lastDefinedIndex","undefined","unpositionedStops","startPosition","endPosition","increment","j"],"sources":["processBackgroundImage.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n'use strict';\n\nimport type {ProcessedColorValue} from './processColor';\nimport type {GradientValue} from './StyleSheetTypes';\n\nconst processColor = require('./processColor').default;\nconst DIRECTION_KEYWORD_REGEX =\n  /^to\\s+(?:top|bottom|left|right)(?:\\s+(?:top|bottom|left|right))?/i;\nconst ANGLE_UNIT_REGEX = /^([+-]?\\d*\\.?\\d+)(deg|grad|rad|turn)$/i;\n\ntype LinearGradientDirection =\n  | {type: 'angle', value: number}\n  | {type: 'keyword', value: string};\n\ntype ParsedGradientValue = {\n  type: 'linearGradient',\n  direction: LinearGradientDirection,\n  colorStops: $ReadOnlyArray<{\n    color: ProcessedColorValue,\n    position: number,\n  }>,\n};\n\nconst DEFAULT_DIRECTION: LinearGradientDirection = {\n  type: 'angle',\n  value: 180,\n};\n\nexport default function processBackgroundImage(\n  backgroundImage: ?($ReadOnlyArray<GradientValue> | string),\n): $ReadOnlyArray<ParsedGradientValue> {\n  let result: $ReadOnlyArray<ParsedGradientValue> = [];\n  if (backgroundImage == null) {\n    return result;\n  }\n\n  if (typeof backgroundImage === 'string') {\n    result = parseCSSLinearGradient(backgroundImage.replace(/\\n/g, ' '));\n  } else if (Array.isArray(backgroundImage)) {\n    for (const bgImage of backgroundImage) {\n      const processedColorStops: Array<{\n        color: ProcessedColorValue,\n        position: number | null,\n      }> = [];\n      for (let index = 0; index < bgImage.colorStops.length; index++) {\n        const colorStop = bgImage.colorStops[index];\n        const processedColor = processColor(colorStop.color);\n        if (processedColor == null) {\n          // If a color is invalid, return an empty array and do not apply gradient. Same as web.\n          return [];\n        }\n        if (colorStop.positions != null && colorStop.positions.length > 0) {\n          for (const position of colorStop.positions) {\n            if (position.endsWith('%')) {\n              processedColorStops.push({\n                color: processedColor,\n                position: parseFloat(position) / 100,\n              });\n            } else {\n              // If a position is invalid, return an empty array and do not apply gradient. Same as web.\n              return [];\n            }\n          }\n        } else {\n          processedColorStops.push({\n            color: processedColor,\n            position: null,\n          });\n        }\n      }\n\n      let direction: LinearGradientDirection = DEFAULT_DIRECTION;\n      const bgDirection =\n        bgImage.direction != null ? bgImage.direction.toLowerCase() : null;\n\n      if (bgDirection != null) {\n        if (ANGLE_UNIT_REGEX.test(bgDirection)) {\n          const parsedAngle = getAngleInDegrees(bgDirection);\n          if (parsedAngle != null) {\n            direction = {\n              type: 'angle',\n              value: parsedAngle,\n            };\n          } else {\n            // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n            return [];\n          }\n        } else if (DIRECTION_KEYWORD_REGEX.test(bgDirection)) {\n          const parsedDirection = getDirectionForKeyword(bgDirection);\n          if (parsedDirection != null) {\n            direction = parsedDirection;\n          } else {\n            // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n            return [];\n          }\n        } else {\n          // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      }\n\n      const fixedColorStops = getFixedColorStops(processedColorStops);\n\n      result = result.concat({\n        type: 'linearGradient',\n        direction,\n        colorStops: fixedColorStops,\n      });\n    }\n  }\n\n  return result;\n}\n\nfunction parseCSSLinearGradient(\n  cssString: string,\n): $ReadOnlyArray<ParsedGradientValue> {\n  const gradients = [];\n  let match;\n\n  // matches one or more linear-gradient functions in CSS\n  const linearGradientRegex = /linear-gradient\\s*\\(((?:\\([^)]*\\)|[^())])*)\\)/gi;\n\n  while ((match = linearGradientRegex.exec(cssString))) {\n    const gradientContent = match[1];\n    const parts = gradientContent.split(',');\n    let direction: LinearGradientDirection = DEFAULT_DIRECTION;\n    const trimmedDirection = parts[0].trim().toLowerCase();\n\n    // matches individual color stops in a gradient function\n    // supports various color formats: named colors, hex colors, rgb(a), and hsl(a)\n    // e.g. \"red 20%\", \"blue 50%\", \"rgba(0, 0, 0, 0.5) 30% 50%\"\n    // TODO: does not support color hint syntax yet. It is WIP.\n    const colorStopRegex =\n      /\\s*((?:(?:rgba?|hsla?)\\s*\\([^)]+\\))|#[0-9a-fA-F]+|[a-zA-Z]+)(?:\\s+(-?[0-9.]+%?)(?:\\s+(-?[0-9.]+%?))?)?\\s*/gi;\n\n    if (ANGLE_UNIT_REGEX.test(trimmedDirection)) {\n      const parsedAngle = getAngleInDegrees(trimmedDirection);\n      if (parsedAngle != null) {\n        direction = {\n          type: 'angle',\n          value: parsedAngle,\n        };\n        parts.shift();\n      } else {\n        // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n    } else if (DIRECTION_KEYWORD_REGEX.test(trimmedDirection)) {\n      const parsedDirection = getDirectionForKeyword(trimmedDirection);\n      if (parsedDirection != null) {\n        direction = parsedDirection;\n        parts.shift();\n      } else {\n        // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n    } else if (!colorStopRegex.test(trimmedDirection)) {\n      // If first part is not an angle/direction or a color stop, return an empty array and do not apply any gradient. Same as web.\n      return [];\n    }\n    colorStopRegex.lastIndex = 0;\n\n    const colorStops = [];\n    const fullColorStopsStr = parts.join(',');\n    let colorStopMatch;\n    while ((colorStopMatch = colorStopRegex.exec(fullColorStopsStr))) {\n      const [, color, position1, position2] = colorStopMatch;\n      const processedColor = processColor(color.trim().toLowerCase());\n      if (processedColor == null) {\n        // If a color is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n\n      if (typeof position1 !== 'undefined') {\n        if (position1.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position1) / 100,\n          });\n        } else {\n          // If a position is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      } else {\n        colorStops.push({\n          color: processedColor,\n          position: null,\n        });\n      }\n\n      if (typeof position2 !== 'undefined') {\n        if (position2.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position2) / 100,\n          });\n        } else {\n          // If a position is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      }\n    }\n\n    const fixedColorStops = getFixedColorStops(colorStops);\n\n    gradients.push({\n      type: 'linearGradient',\n      direction,\n      colorStops: fixedColorStops,\n    });\n  }\n\n  return gradients;\n}\n\nfunction getDirectionForKeyword(direction?: string): ?LinearGradientDirection {\n  if (direction == null) {\n    return null;\n  }\n  // Remove extra whitespace\n  const normalized = direction.replace(/\\s+/g, ' ').toLowerCase();\n\n  switch (normalized) {\n    case 'to top':\n      return {type: 'angle', value: 0};\n    case 'to right':\n      return {type: 'angle', value: 90};\n    case 'to bottom':\n      return {type: 'angle', value: 180};\n    case 'to left':\n      return {type: 'angle', value: 270};\n    case 'to top right':\n    case 'to right top':\n      return {type: 'keyword', value: 'to top right'};\n    case 'to bottom right':\n    case 'to right bottom':\n      return {type: 'keyword', value: 'to bottom right'};\n    case 'to top left':\n    case 'to left top':\n      return {type: 'keyword', value: 'to top left'};\n    case 'to bottom left':\n    case 'to left bottom':\n      return {type: 'keyword', value: 'to bottom left'};\n    default:\n      return null;\n  }\n}\n\nfunction getAngleInDegrees(angle?: string): ?number {\n  if (angle == null) {\n    return null;\n  }\n  const match = angle.match(ANGLE_UNIT_REGEX);\n  if (!match) {\n    return null;\n  }\n\n  const [, value, unit] = match;\n\n  const numericValue = parseFloat(value);\n  switch (unit) {\n    case 'deg':\n      return numericValue;\n    case 'grad':\n      return numericValue * 0.9; // 1 grad = 0.9 degrees\n    case 'rad':\n      return (numericValue * 180) / Math.PI;\n    case 'turn':\n      return numericValue * 360; // 1 turn = 360 degrees\n    default:\n      return null;\n  }\n}\n\n// https://drafts.csswg.org/css-images-4/#color-stop-fixup\nfunction getFixedColorStops(\n  colorStops: $ReadOnlyArray<{\n    color: ProcessedColorValue,\n    position: number | null,\n  }>,\n): Array<{\n  color: ProcessedColorValue,\n  position: number,\n}> {\n  let fixedColorStops: Array<{\n    color: ProcessedColorValue,\n    position: number,\n  }> = [];\n  let hasNullPositions = false;\n  let maxPositionSoFar = colorStops[0].position ?? 0;\n  for (let i = 0; i < colorStops.length; i++) {\n    const colorStop = colorStops[i];\n    let newPosition = colorStop.position;\n    if (newPosition === null) {\n      // Step 1:\n      // If the first color stop does not have a position,\n      // set its position to 0%. If the last color stop does not have a position,\n      // set its position to 100%.\n      if (i === 0) {\n        newPosition = 0;\n      } else if (i === colorStops.length - 1) {\n        newPosition = 1;\n      }\n    }\n    // Step 2:\n    // If a color stop or transition hint has a position\n    // that is less than the specified position of any color stop or transition hint\n    // before it in the list, set its position to be equal to the\n    // largest specified position of any color stop or transition hint before it.\n    if (newPosition !== null) {\n      newPosition = Math.max(newPosition, maxPositionSoFar);\n      fixedColorStops[i] = {\n        color: colorStop.color,\n        position: newPosition,\n      };\n      maxPositionSoFar = newPosition;\n    } else {\n      hasNullPositions = true;\n    }\n  }\n\n  // Step 3:\n  // If any color stop still does not have a position,\n  // then, for each run of adjacent color stops without positions,\n  // set their positions so that they are evenly spaced between the preceding and\n  // following color stops with positions.\n  if (hasNullPositions) {\n    let lastDefinedIndex = 0;\n    for (let i = 1; i < fixedColorStops.length; i++) {\n      if (fixedColorStops[i] !== undefined) {\n        const unpositionedStops = i - lastDefinedIndex - 1;\n        if (unpositionedStops > 0) {\n          const startPosition = fixedColorStops[lastDefinedIndex].position;\n          const endPosition = fixedColorStops[i].position;\n          const increment =\n            (endPosition - startPosition) / (unpositionedStops + 1);\n          for (let j = 1; j <= unpositionedStops; j++) {\n            fixedColorStops[lastDefinedIndex + j] = {\n              color: colorStops[lastDefinedIndex + j].color,\n              position: startPosition + increment * j,\n            };\n          }\n        }\n        lastDefinedIndex = i;\n      }\n    }\n  }\n\n  return fixedColorStops;\n}\n"],"mappings":"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","ignoreList":[]}